import { configGet } from './config';
import { dirRead, fileAdd, fileDate, fileJsonCreate, fileJsonLoad } from './file';
import { pathGetId, pathGetRepo, pathGetVersion } from './utils';
import { ProjectInterface, ProjectLocal, ProjectType, ProjectTypes } from './types/project';

async function projectGetLocal(id: string, version?: string): Promise<ProjectLocal> {
  const projects: ProjectLocal[] = await projectsGetLocal();
  return projects.filter((project: ProjectLocal) => {
    return project.id === id;
  })[0];
}

async function projectsGetLocal(): Promise<ProjectLocal[]> {
  const projectTypes: ProjectTypes = configGet('projectTypes');
  const projectExts: string[] = Object.keys(projectTypes).map((projectTypeKey: string) => {
    return projectTypes[projectTypeKey as keyof ProjectTypes].ext;
  });
  const projectFolderExts: string = `/**/*.{${projectExts.join(',')}}`;
  const projectPaths: string[] = dirRead(`${configGet('projectFolder')}${projectFolderExts}`);
  const projects: ProjectLocal[] = [];
  projectPaths.forEach((projectPath: string) => {
    if (projectPath.includes('/Backup/')) return;
    const jsonPath: string = projectPath.substring(0, projectPath.lastIndexOf('.')) + '.json';
    const relativePath: string = projectPath.replace(configGet('projectFolder') + '/', '');
    let project: any = fileJsonLoad(jsonPath);
    if (!project) {
      project = projectValidate(projectPath, { files: true, json: true });
    }
    // Use installed path for id, repo and version (instead of autogenerated json)
    project.id = pathGetId(relativePath);
    project.path = projectPath;
    project.repo = pathGetRepo(relativePath);
    project.status = 'installed';
    project.version = pathGetVersion(projectPath);
    projects.push(project);
  });
  return projects;
}

function projectValidate(path: string, options?: any): ProjectInterface {
  const ext: string = path.substring(path.lastIndexOf('.') + 1);
  const folder: string = path.substring(0, path.lastIndexOf('/'));
  const filename: string = path.substring(path.lastIndexOf('/') + 1, path.lastIndexOf('.'));
  const projectTypes: ProjectTypes = configGet('projectTypes');
  let projectType: ProjectType = {
    name: 'Ableton',
    ext: 'als',
  };
  Object.keys(projectTypes).forEach((key: string) => {
    const currentType: ProjectType = projectTypes[key as keyof ProjectTypes];
    if (currentType.ext === ext) {
      projectType = currentType;
    }
  });
  let projectJson: ProjectLocal = {
    id: pathGetId(path),
    author: 'studiorack-user',
    homepage: 'https://studiorack.github.io/studiorack-site/',
    name: filename,
    description: 'Created using StudioRack',
    tags: [projectType.name],
    version: '1.0.0',
    date: fileDate(path).toISOString(),
    type: projectType,
    path: path,
    status: 'installed',
    files: {
      audio: {
        name: '',
        size: 0,
      },
      image: {
        name: '',
        size: 0,
      },
      project: {
        name: '',
        size: 0,
      },
    },
    plugins: {},
  };
  if (options && options.files) {
    projectJson = projectValidateFiles(path, projectJson);
  }
  if (options && options.json) {
    fileJsonCreate(`${folder}/${filename}.json`, projectJson);
  }
  return projectJson;
}

function projectValidateFiles(path: string, json: any): any {
  const ext: string = path.substring(path.lastIndexOf('.') + 1);
  const folder: string = path.substring(0, path.lastIndexOf('/'));
  const filename: string = path.substring(path.lastIndexOf('/') + 1, path.lastIndexOf('.'));
  // Ensure files object exists
  if (!json.files) {
    json.files = {};
  }
  // Add audio, image and zip files
  json = fileAdd(`${folder}/${filename}.wav`, `${filename}.wav`, 'audio', json);
  json = fileAdd(`${folder}/${filename}.png`, `${filename}.png`, 'image', json);
  json = fileAdd(`${folder}/${filename}.${ext}`, `${filename}.${ext}`, 'project', json);
  return json;
}

export { projectGetLocal, projectsGetLocal, projectValidate, projectValidateFiles };
