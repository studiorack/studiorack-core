import { configGet } from './config';
import { dirCreate, dirRead, fileAdd, fileDate, fileJsonCreate, fileJsonLoad, fileLoad, fileOpen } from './file';
import { pathGetDirectory, pathGetExt, pathGetFilename, pathGetRepo, pathGetWithoutExt, safeSlug } from './utils';
import { pluginInstall, pluginUninstall } from './plugin';
import { PluginLocal } from './types/plugin';
import { ProjectInterface, ProjectLocal, ProjectType, ProjectTypes } from './types/project';
const readline = require('readline-sync');

function askQuestion(label: string, input: any, fallback: string) {
  return readline.question(`${label}: ($<defaultInput>) `, {
    defaultInput: input || fallback,
  });
}

function projectCreate(id: string, prompt: boolean = true): ProjectLocal {
  const project: ProjectLocal = projectDefault() as ProjectLocal;
  if (prompt) {
    project.name = askQuestion('Name', project.name, 'My Project');
    project.version = askQuestion('Version', project.version, '1.0.0');
    project.description = askQuestion('Description', project.description, 'My project description');
    project.files.audio.name = askQuestion('Audio', project.files.audio.name, 'Song.wav');
    project.files.image.name = askQuestion('Image', project.files.image.name, 'Song.png');
    project.files.project.name = askQuestion('Main', project.files.project.name, 'Song.als');
  }
  project.id = safeSlug(pathGetFilename(id));
  project.path = pathGetDirectory(id);
  project.repo = pathGetRepo(id);
  project.status = 'installed';
  dirCreate(pathGetDirectory(`${configGet('projectFolder')}/${id}.json`));
  return projectSave(`${configGet('projectFolder')}/${id}.json`, project);
}

function projectDefault(): ProjectInterface {
  return {
    id: 'studiorack-project',
    author: 'studiorack-user',
    homepage: 'https://studiorack.github.io/studiorack-site/',
    name: 'StudioRack Project',
    description: 'Created using StudioRack',
    repo: 'studiorack/studiorack-project',
    tags: ['StudioRack'],
    version: '1.0.0',
    date: new Date().toISOString(),
    type: {
      name: 'Ableton',
      ext: 'als',
    },
    files: {
      audio: {
        name: '',
        size: 0,
      },
      image: {
        name: '',
        size: 0,
      },
      project: {
        name: '',
        size: 0,
      },
    },
    plugins: {},
  };
}

function projectDirectory(project: ProjectInterface, depth?: number): string {
  const projectPaths: string[] = [configGet('projectFolder'), project.id, project.version];
  if (depth) {
    return projectPaths.slice(0, depth).join('/');
  }
  return projectPaths.join('/');
}

async function projectGetLocal(id: string, version?: string): Promise<ProjectLocal> {
  const projects: ProjectLocal[] = await projectsGetLocal();
  return projects.filter((project: ProjectLocal) => {
    return id === `${project.repo}/${project.id}`;
  })[0];
}

async function projectsGetLocal(): Promise<ProjectLocal[]> {
  const projectTypes: ProjectTypes = configGet('projectTypes');
  const projectExts: string[] = Object.keys(projectTypes).map((projectTypeKey: string) => {
    return projectTypes[projectTypeKey as keyof ProjectTypes].ext;
  });
  const projectFolderExts: string = `/**/*.{${projectExts.join(',')}}`;
  const projectPaths: string[] = dirRead(`${configGet('projectFolder')}${projectFolderExts}`);
  const projects: ProjectLocal[] = [];
  projectPaths.forEach((projectPath: string) => {
    if (projectPath.includes('/Backup/')) return;
    const relativePath: string = projectPath.replace(configGet('projectFolder') + '/', '');
    let project: any = fileJsonLoad(`${pathGetWithoutExt(projectPath)}.json`);
    if (!project) {
      project = projectValidate(projectPath, { files: true, json: true });
    }
    // Use installed path for id, repo and version (instead of autogenerated json)
    project.id = safeSlug(pathGetFilename(relativePath));
    project.path = pathGetDirectory(projectPath);
    project.repo = pathGetRepo(relativePath);
    project.status = 'installed';
    // project.version = pathGetVersion(projectPath);
    projects.push(project);
  });
  return projects;
}

async function projectInstall(path: string, id?: string, version?: string): Promise<ProjectLocal> {
  const project: ProjectLocal = projectLoad(path);
  if (id) {
    const pluginLocal: PluginLocal = await pluginInstall(id, version);
    if (pluginLocal) {
      project.plugins[id] = pluginLocal.version;
    }
  } else {
    for (const pluginId in project.plugins) {
      await pluginInstall(pluginId, project.plugins[pluginId]);
    }
  }
  return projectSave(path, project);
}

function projectLoad(path: string): ProjectLocal {
  const projectJson: ProjectLocal = fileJsonLoad(path);
  if (projectJson && !projectJson.plugins) {
    projectJson.plugins = {};
  }
  return projectJson;
}

function projectSave(path: string, config: ProjectLocal): ProjectLocal {
  fileJsonCreate(path, config);
  return config;
}

async function projectStart(path: string): Promise<Buffer> {
  const project: ProjectLocal = projectLoad(path);
  return fileOpen(`${pathGetDirectory(path)}/${project.files.project?.name}`);
}

function projectType(ext: string): ProjectType {
  const projectTypes: ProjectTypes = configGet('projectTypes');
  let type: ProjectType = {
    name: 'Ableton',
    ext: 'als',
  };
  Object.keys(projectTypes).forEach((key: string) => {
    const currentType: ProjectType = projectTypes[key as keyof ProjectTypes];
    if (currentType.ext === ext) {
      type = currentType;
    }
  });
  return type;
}

async function projectUninstall(path: string, id?: string, version?: string): Promise<ProjectLocal> {
  const project = projectLoad(path);
  if (id) {
    let result = version;
    if (!version) {
      result = project.plugins[id];
    }
    const pluginLocal: PluginLocal = await pluginUninstall(id, result);
    if (pluginLocal) {
      delete project.plugins[id];
    }
  } else {
    for (const pluginId in project.plugins) {
      await pluginUninstall(pluginId, project.plugins[pluginId]);
    }
  }
  return projectSave(path, project);
}

function projectValidate(path: string, options?: any): ProjectInterface {
  const relativePath: string = path.replace(configGet('projectFolder') + '/', '');
  const type: ProjectType = projectType(pathGetExt(path));
  let project: ProjectLocal = projectDefault() as ProjectLocal;
  project.date = fileDate(path).toISOString();
  project.id = safeSlug(pathGetFilename(relativePath));
  project.name = pathGetFilename(relativePath);
  project.path = pathGetDirectory(path);
  project.repo = pathGetRepo(relativePath);
  project.status = 'installed';
  project.tags = [type.name];
  project.type = type;
  if (options && options.files) {
    project = projectValidateFiles(path, project);
  }
  if (options && options.json) {
    fileJsonCreate(`${pathGetDirectory(path)}/${pathGetFilename(path)}.json`, project);
  }
  return project;
}

function projectValidateFiles(pathItem: string, json: any): any {
  const ext: string = pathGetExt(pathItem);
  const directory: string = pathGetDirectory(pathItem);
  const filename: string = pathGetFilename(pathItem);
  // Ensure files object exists
  if (!json.files) {
    json.files = {};
  }
  // Add audio, image and zip files
  json = fileAdd(`${directory}/${filename}.wav`, `${filename}.wav`, 'audio', json);
  json = fileAdd(`${directory}/${filename}.png`, `${filename}.png`, 'image', json);
  json = fileAdd(`${directory}/${filename}.${ext}`, `${filename}.${ext}`, 'project', json);
  return json;
}

export {
  projectCreate,
  projectDefault,
  projectDirectory,
  projectGetLocal,
  projectsGetLocal,
  projectInstall,
  projectLoad,
  projectSave,
  projectStart,
  projectType,
  projectUninstall,
  projectValidate,
  projectValidateFiles,
};
